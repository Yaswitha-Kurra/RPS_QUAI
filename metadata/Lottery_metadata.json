"{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"buyTicket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlayers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasEntered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pickWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Lottery.sol\":\"Lottery\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"contracts/Lottery.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\ncontract Lottery {\\n    address public owner;\\n    address[] public players;\\n    mapping(address => bool) public hasEntered;\\n    uint public ticketPrice;\\n    uint public roundEndTime;\\n    uint public feePercent = 5;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        ticketPrice = 5 ether; // 5 Quai (Quai decimals are 18 like ETH)\\n        roundEndTime = block.timestamp + 7 days;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner can call this function\\\");\\n        _;\\n    }\\n\\n    function buyTicket() external payable {\\n        require(block.timestamp < roundEndTime, \\\"Round has ended\\\");\\n        require(msg.value == ticketPrice, \\\"Incorrect ticket price\\\");\\n        require(!hasEntered[msg.sender], \\\"You have already bought a ticket\\\");\\n\\n        players.push(msg.sender);\\n        hasEntered[msg.sender] = true;\\n    }\\n\\n    function pickWinners() external onlyOwner {\\n        require(block.timestamp >= roundEndTime, \\\"Round not yet ended\\\");\\n        require(players.length >= 1, \\\"Not enough players\\\");\\n\\n        uint balance = address(this).balance;\\n        uint fee = (balance * feePercent) / 100;\\n        uint prizePool = balance - fee;\\n\\n        payable(owner).transfer(fee);\\n\\n        uint256[10] memory prizePercents = [\\n            uint256(30),\\n            uint256(20),\\n            uint256(15),\\n            uint256(10),\\n            uint256(7),\\n            uint256(5),\\n            uint256(4),\\n            uint256(3),\\n            uint256(3),\\n            uint256(3)\\n        ];\\n\\n\\n        address[] memory winners = selectWinners();\\n\\n        for (uint i = 0; i < winners.length; i++) {\\n            uint prize = (prizePool * prizePercents[i]) / 100;\\n            payable(winners[i]).transfer(prize);\\n        }\\n\\n        resetLottery();\\n    }\\n\\n    function selectWinners() private view returns (address[] memory) {\\n        uint winnersCount = players.length < 10 ? players.length : 10;\\n        address[] memory winners = new address[](winnersCount);\\n        address[] memory tempPlayers = players;\\n\\n        for (uint i = 0; i < winnersCount; i++) {\\n            uint randIndex = random(i) % tempPlayers.length;\\n            winners[i] = tempPlayers[randIndex];\\n\\n            // Remove the selected winner from tempPlayers array\\n            tempPlayers[randIndex] = tempPlayers[tempPlayers.length - 1];\\n            assembly { mstore(tempPlayers, sub(mload(tempPlayers), 1)) }\\n        }\\n\\n        return winners;\\n    }\\n\\n    function random(uint salt) private view returns (uint) {\\n        return uint(keccak256(abi.encodePacked(block.timestamp, block.prevrandao, players, salt)));\\n    }\\n\\n    function resetLottery() private {\\n        for (uint i = 0; i < players.length; i++) {\\n            hasEntered[players[i]] = false;\\n        }\\n        delete players;\\n        roundEndTime = block.timestamp + 7 days;\\n    }\\n\\n    function getPlayers() external view returns (address[] memory) {\\n        return players;\\n    }\\n\\n    function getTimeLeft() external view returns (uint) {\\n        if (block.timestamp >= roundEndTime) return 0;\\n        return roundEndTime - block.timestamp;\\n    }\\n}\",\"keccak256\":\"0xe2b23d51dcaa5aa2b3d5f0820a5aee5a57d4e370ca9f00ff2c08f4a9f54039c9\",\"license\":\"MIT\"}},\"version\":1}"